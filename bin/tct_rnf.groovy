#!/usr/bin/env groovy

// import static groovy.json.JsonOutput.* //for debuggig only
import java.util.zip.GZIPInputStream
import java.util.zip.GZIPOutputStream

@Grab('info.picocli:picocli-groovy:4.1.2') //command line interface

@Command(header = [

        $/@|bold,blue  ╔╦╗╔═╗╔╦╗  ╦═╗╔╗╔╔═╗   |@/$,
        $/@|bold,blue   ║ ║   ║   ╠╦╝║║║╠╣    |@/$,
        $/@|bold,blue   ╩ ╚═╝ ╩   ╩╚═╝╚╝╚     |@/$
        ],
        description = "Conver RNF reads coordinates from transcriptome to genome space.",
        showDefaultValues = true,
        footerHeading = "%nFootnote(s)%n",
        footer = ["[1] ASCII Art thanks to http://patorjk.com/software/taag/"]
)
@picocli.groovy.PicocliScript
import groovy.transform.Field
import java.security.MessageDigest
import static picocli.CommandLine.*

@Option(names = ["-t", "--transcriptome"], description = ["Transcriptome generated using `gffread -W` and used to simulate input reads."], required = true)
@Field private String transcriptome

@Option(names = ["-g", "--genome-index"], description = ["Genome index file required for order of reference sequences."], required = true)
@Field private String genomeidx

@Option(names = ["-f", "--in-forward"], description = ["R1 input file name"], required = true)
@Field private String inforward
@Option(names = ["-r", "--in-reverse"], description = ["R2 input file name"], required = true)
@Field private String inreverse

@Option(names = ["-F", "--out-forward"], description = ["R1 output file name"], required = true)
@Field private String outforward
@Option(names = ["-R", "--out-reverse"], description = ["R2 output file name"], required = true)
@Field private String outreverse

@Option(names= ["-h", "--help"], usageHelp=true, description="Show this help message and exit.")
@Field private boolean helpRequested


// System.setProperty(picocli.usage.width,160)



final int PAD4BASES = 9
final int PAD4CHROMOSOMES = 5
final int BUFFER_SIZE = 8192
final String NEWLINE = System.lineSeparator();

File refFile = new File(transcriptome)
File genomeIdxFile = new File(genomeidx)
File fastqFile1 = new File(inforward)
File fastqFile2 = new File(inreverse)
//File fastqFile1 = new File('A_thaliana_TAIR10_chr1_with_gff_ArtIllumina_reads.1.fq.gz')
//File fastqFile2 = new File('A_thaliana_TAIR10_chr1_with_gff_ArtIllumina_reads.2.fq.gz')
File outFile1 = new File(outforward);
File outFile2 = new File(outreverse);
append = false
writer1 = new BufferedWriter(new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(outFile1, append)), "UTF-8"), BUFFER_SIZE);
writer2 = new BufferedWriter(new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(outFile2, append)), "UTF-8"), BUFFER_SIZE);

//Parse and store order of sequences in genome file - these are required due to RNF format relying on order of ref seqs
int gIdx = 0;
genomeIdx = [:]
genomeIdxFile.withReader { source ->
  String line
  while( line = source.readLine() ) {
    toks = line.split('\t')
    genomeIdx << [(toks[0]): (++gIdx).toString().padLeft(PAD4CHROMOSOMES,'0')] //Storing sequential numbers as padded strings not to repeat that for each read
  }
}
// println genomeIdx

//Parse and store infor generated by gffread when extracting transcripts from genome
refs = []
refFile.withReader { source ->
  String line
  while( line = source.readLine()) {
    if(line =~ /^>/) {
      toks = line.split(' ')
      record = [:]
      toks.each { tok ->
        subtoks = tok.split(':|=')
        record.(subtoks[0]) = subtoks[0] == 'loc' ? subtoks[1].split('\\|') : subtoks[1].split(',|\\|')*.split('-')
        if(subtoks[0] =~ /(exons)|(segs)/ ) {
          record.(subtoks[0]) = record.(subtoks[0]).collect{ it*.toInteger() }
        }
      }
      refs << record
    }
  }
}

//Process reads
try {
  gzipStream1 = new GZIPInputStream(new FileInputStream(fastqFile1), BUFFER_SIZE);
  content1 = new BufferedReader(new InputStreamReader(gzipStream1, "UTF-8"), BUFFER_SIZE);
  gzipStream2 = new GZIPInputStream(new FileInputStream(fastqFile2), BUFFER_SIZE);
  content2 = new BufferedReader(new InputStreamReader(gzipStream2, "UTF-8"), BUFFER_SIZE);
  i = 4
  while ((line1 = content1.readLine()) != null && !line1.isEmpty() && (line2 = content2.readLine()) != null && !line2.isEmpty() ) {
    if(i++ % 4 != 0 ) {
      //JUST OUTPUT/STORE LINE AS IS
      writer1.write(line1);
      writer1.write(NEWLINE);
      writer2.write(line2);
      writer2.write(NEWLINE);
      continue;
    }
    split1 = line1.split('__')
    //  split2 = line2.split('__') //no need to process R2 ID line separately as conte

    coords = split1[2].replaceAll('\\(','').replaceAll('\\)','')
    coordsSplit = coords.split(',')

    //FIELDS TO BE USED
    ref = coordsSplit[1].toInteger()
    //FILEDS TO BE MODIFIED
    start = coordsSplit[3].toInteger()
    end = coordsSplit[4].toInteger()
    startMate = coordsSplit[8].toInteger()
    endMate = coordsSplit[9].toInteger()

    // println(prettyPrint(toJson(coordsSplit)))
    refRecord = refs[ref-1]
    // println(prettyPrint(toJson(refRecord)))

    //CONVERT REF ID: take the stored reference ID and get its sequential number in the original genome
    // coordsSplit[1] = coordsSplit[6] = refRecord.loc[0].padLeft(PAD4CHROMOSOMES,'0') //WRONG! USING sequence ID NOT ITS ORDER NUMBER
    // println refRecord.loc + " -> " + genomeIdx.(refRecord.loc[0])
    coordsSplit[1] = coordsSplit[6] = genomeIdx.(refRecord.loc[0])

    // System.exit(1)

    //CONVERT COORDINATES
    translatedStart = translateAndPad(start, refRecord, PAD4BASES)
    translatedEnd = translateAndPad(end, refRecord, PAD4BASES)
    translatedStartMate = translateAndPad(startMate, refRecord, PAD4BASES)
    translatedEndMate = translateAndPad(endMate, refRecord, PAD4BASES)
    coordsSplit[3] = translatedStart < translatedEnd ? translatedStart : translatedEnd
    coordsSplit[4] = translatedStart >= translatedEnd ? translatedStart : translatedEnd
    coordsSplit[8] = translatedStartMate < translatedEndMate ? translatedStartMate : translatedEndMate
    coordsSplit[9] = translatedStartMate >= translatedEndMate ? translatedStartMate : translatedEndMate

    //RE-CONSTITUTE READ HEADER
    //  println(prettyPrint(toJson(split1)))
    StringBuilder sb = new StringBuilder()
    sb.append('(')
    sb.append(coordsSplit[0..4].join(',') )
    sb.append('),(')
    sb.append(coordsSplit[5..9].join(',') )
    sb.append(')')
    split1[2] = sb.toString()
    outline = split1.join('__')

    writer1.write(outline);
    writer1.write(NEWLINE);
    writer2.write(outline[0..-2]+'2');
    writer2.write(NEWLINE);
  }
} catch (FileNotFoundException ex) {
  ex.printStackTrace();
} catch (InterruptedException ex) {
  ex.printStackTrace();
} catch (IOException ex) {
  ex.printStackTrace();
} finally {
  try {
    if (writer1 != null) {
      writer1.close();
    }
    if (writer2 != null) {
      writer2.close();
    }
  } catch (IOException ex) {
    ex.printStackTrace();
  }
}


String translateAndPad(int position, Map record, int padding) {
  return translate(position, record).toString().padLeft(padding,'0')
}

int translate (int position, Map record) {
  boolean forward = record.loc[2].equals('+')
  int numrecords = record.segs.size()

  for(int i=0; i<numrecords; i++) {
    seg = record.segs[i]
    if(position >= seg[0] && position <= seg[1]) {
      if(forward) {
        return record.exons[i][0]+position-seg[0]
      } else {
        return record.exons[numrecords-i-1][0]+(seg[1]-position)
      }
    }
  }
  return Integer.MIN_VALUE;
}